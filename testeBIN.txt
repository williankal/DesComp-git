
-- Segundos = REG[0] REG[1]

-- Uso geral = REG[2] 

-- Clock_check = REG[3]

-- Armazenanmento de valor na RAM =  MEM[10] unidades

--                                    MEM[11] dezenas

--                                    MEM[12] centenas

--                                    MEM[13] milhares

--                                    MEM[14] dez milhares

--                                    MEM[15] cent milhares

--                                    MEM[16] flag

-- Armazenamento de limite na RAM = MEM[30] unidades

--                                  MEM[31] dezenas

--                                  MEM[32] centenas

--                                  MEM[33] milhares

--                                  MEM[34] dez milhares

--                                  MEM[35] cent milhares

--

--# MEM[0] = 0

--# MEM[1] = 1

--# MEM[2] = 9

--# MEM[3] = 10
--SP:

--LIMPA BOTOESBACK
tmp(0) := STA & R2 & '1' & x"FF";	-- STA %R2 .CLEARKEY0 	#Limpa KEY 0
tmp(1) := STA & R2 & '1' & x"FE";	-- STA %R2 .CLEARKEY1 	#Limpa KEY 1
tmp(2) := STA & R2 & '1' & x"FD";	-- STA %R2 .CLEARKEY2 	#Limpa KEY 2
tmp(3) := STA & R2 & '1' & x"FC";	-- STA %R2 .CLEARKEY3 	#Limpa KEY 3
tmp(4) := STA & R2 & '1' & x"FB";	-- STA %R2 .CLEARFPGA 	#Limpa FPGA_RESET
tmp(5) := LDI & R2 & '0' & x"00";	-- LDI %R2 $0 	#Carrega acumulador com valor 0

--ESCREVE 0 NOS DISPLAYS
tmp(6) := STA & R2 & '1' & x"20";	-- STA %R2 .HEX0 	#Armazena o valor 0 no HEX0
tmp(7) := STA & R2 & '1' & x"21";	-- STA %R2 .HEX1 	#Armazena o valor 0 no HEX1
tmp(8) := STA & R2 & '1' & x"22";	-- STA %R2 .HEX2 	#Armazena o valor 0 no HEX2
tmp(9) := STA & R2 & '1' & x"23";	-- STA %R2 .HEX3 	#Armazena o valor 0 no HEX3
tmp(10) := STA & R2 & '1' & x"24";	-- STA %R2 .HEX4 	#Armazena o valor 0 no HEX4
tmp(11) := STA & R2 & '1' & x"25";	-- STA %R2 .HEX5 	#Armazena o valor 0 no HEX5

--APAGANDO OS LEDS
tmp(12) := LDI & R2 & '0' & x"00";	-- LDI %R2 $0
tmp(13) := STA & R2 & '1' & x"00";	-- STA %R2 .LED07 	#Armazena o valor 0 no LEDR7~0
tmp(14) := STA & R2 & '1' & x"01";	-- STA %R2 .LED8 	#Armazena o valor 0 no LEDR8
tmp(15) := STA & R2 & '1' & x"02";	-- STA %R2 .LED9 	#Armazena o valor 0 no LEDR9

--VARIAVEIS QUE ARMAZENAM O VALOR DO DISPLAY
tmp(16) := LDI & R2 & '0' & x"00";	-- LDI %R2 $0 
tmp(17) := STA & R2 & '0' & x"0B";	-- STA %R2 @11 	#Armazena o valor do acumulador em MEM[11](dezenas)
tmp(18) := STA & R2 & '0' & x"0C";	-- STA %R2 @12 	#Armazena o valor do acumulador em MEM[12](centenas)
tmp(19) := STA & R2 & '0' & x"0D";	-- STA %R2 @13 	#Armazena o valor do acumulador em MEM[13](milhares)
tmp(20) := STA & R2 & '0' & x"0E";	-- STA %R2 @14 	#Armazena o valor do acumulador em MEM[14](dez milhares)
tmp(21) := STA & R2 & '0' & x"0F";	-- STA %R2 @15 	#Armazena o valor do acumulador em MEM[15](cent milhares)

--FLAG 
tmp(22) := STA & R2 & '0' & x"10";	-- STA %R2 @16 	#Armazena o valor do acumulador em MEM[16]=0 (flag)

--VARIAVEIS DE COMPARAÇÃO 
tmp(23) := LDI & R0 & '0' & x"00";	-- LDI %R0 $0
tmp(24) := LDI & R2 & '0' & x"00";	-- LDI %R2 $0
tmp(25) := STA & R2 & '0' & x"00";	-- STA %R2 @0 	#Armaena o valor do acumulador em MEM[0]
tmp(26) := LDI & R2 & '0' & x"09";	-- LDI %R2 $9 	#Carrega acumulador com valor 9
tmp(27) := STA & R2 & '0' & x"01";	-- STA %R2 @1 	#Armazena o valor do acumulador em MEM[2]
tmp(28) := LDI & R2 & '0' & x"0A";	-- LDI %R2 $10 	#Carrega acumulador com valor 10
tmp(29) := STA & R2 & '0' & x"02";	-- STA %R2 @2 	#Armazena o valor do acumulador em MEM[3]

--ARMAZENANDO LIMITES DE CONTAGEM
tmp(30) := LDI & R2 & '0' & x"09";	-- LDI %R2 $9 	#Carrega acumulador com valor 9
tmp(31) := STA & R2 & '0' & x"1E";	-- STA %R2 @30  	#Armazena o limie de contagem em MEM[30] (segundos)
tmp(32) := STA & R2 & '0' & x"20";	-- STA %R2 @32 	#Armazena o limie de contagem em MEM[32] (minutos)
tmp(33) := LDI & R2 & '0' & x"05";	-- LDI %R2 $5 
tmp(34) := STA & R2 & '0' & x"1F";	-- STA %R2 @31 	#Armazena o limie de contagem em MEM[31] (segundos dezenas)
tmp(35) := STA & R2 & '0' & x"21";	-- STA %R2 @33 	#Armazena o limie de contagem em MEM[33] (minutos dezenas)
tmp(36) := LDI & R2 & '0' & x"04";	-- LDI %R2 $4
tmp(37) := STA & R2 & '0' & x"22";	-- STA %R2 @34 	#Armazena o limie de contagem em MEM[34] (horas)
tmp(38) := LDI & R2 & '0' & x"02";	-- LDI %R2 $2
tmp(39) := STA & R2 & '0' & x"23";	-- STA %R2 @35 	#Armazena o limie de contagem em MEM[35] (horas dezenas)
--L:

--CHECA CLOCK
tmp(40) := LDA & R3 & '1' & x"65";	-- LDA %R3 .HABCLOCK 	#Carrega acumulador com o valor de KEY0
tmp(41) := ANDI & R3 & '0' & x"01";	-- ANDI %R3 $1 	#Faz a operação AND com o valor 1
tmp(42) := CEQ & R3 & '0' & x"01";	-- CEQ %R3 @1 	#OLha para se o valor do acumulador é igual a 1 (Se key0 foi pressionado)
tmp(43) := JEQ & R3 & '0' & x"31";	-- JEQ %R3 .INCREMENTA 	#Se for igual pula para fpga_reset
--B:

--CHECA FPGA_RESET
tmp(44) := LDA & R2 & '1' & x"64";	-- LDA %R2 .RST_FPGA 	#Carrega acumulador com o valor de FPGA_RESET
tmp(45) := ANDI & R2 & '0' & x"01";	-- ANDI %R2 $1 	#Faz a operação AND com o valor 1
tmp(46) := CEQ & R2 & '0' & x"01";	-- CEQ %R2 @1 	#Compara se o valor do acumulador é igual a 0 
tmp(47) := JEQ & R2 & '0' & x"00";	-- JEQ %R2 .SETUP 	#Se  n foi pressionado pulta para atualiza display
tmp(48) := JMP & R2 & '0' & x"28";	-- JMP %R2 .LOOP 	#Se n foi pressionado volta para o loop principal

--loop INCREMENTO
--IEMENTA:
tmp(49) := STA & R3 & '1' & x"F8";	-- STA %R3 .CLEARCLOCK 	#Limpa KEY 0
tmp(50) := LDI & R2 & '0' & x"01";	-- LDI %R2 $1 	#Carrega acumulador com valor 1
tmp(51) := STA & R2 & '1' & x"01";	-- STA %R2 .LED8 	#Armazena o valor 1 no LEDR8
tmp(52) := JMP & R0 & '0' & x"35";	-- JMP %R0 .SUBROTINA_CLOCK
--SOTINA_CLOCK: 
tmp(53) := ADDI & R0 & '0' & x"01";	-- ADDI %R0 $1 	#Soma 1 ao valor do acumulador
tmp(54) := CEQ & R0 & '0' & x"1E";	-- CEQ %R0 @30 	#Compara o valor em MEM[30]
tmp(55) := JEQ & R0 & '0' & x"3A";	-- JEQ %R0 .INCREMENTO_DEZENA 	#Se for igual a 10 pula para incremento dezena
tmp(56) := STA & R0 & '1' & x"20";	-- STA %R0 .HEX0
tmp(57) := JMP & R0 & '0' & x"28";	-- JMP %R0 .LOOP 	#Volta para o loop principal
--IEMENTO_DEZENA:
tmp(58) := LDI & R0 & '0' & x"00";	-- LDI %R0 $0 	#Zera segundos
tmp(59) := STA & R0 & '1' & x"20";	-- STA %R0 .HEX0 
tmp(60) := LDI & R1 & '0' & x"00";	-- LDI %R1 $0 	#Zera 
tmp(61) := ADDI & R1 & '0' & x"01";	-- ADDI %R1 $1 	#Soma 1 ao valor do REG[1]
tmp(62) := CEQ & R1 & '0' & x"1F";	-- CEQ %R1 @31 	#Compara o valor em MEM[31]
tmp(63) := JEQ & R1 & '0' & x"42";	-- JEQ %R1 .INCREMENTO_MINUTO 	#Se for igual a 10 pula para incremento minuto
tmp(64) := STA & R1 & '1' & x"21";	-- STA %R1 .HEX1
tmp(65) := JMP & R1 & '0' & x"28";	-- JMP %R1 .LOOP 	#Volta para o loop principal
--IEMENTO_MINUTO:
tmp(66) := JMP & R1 & '0' & x"28";	-- JMP %R1 .LOOP
tmp(67) := JMP & R0 & '0' & x"2C";	-- JMP %R0 .BACK

--SUBROTINA RESET FPGA
tmp(68) := STA & R0 & '1' & x"FD";	-- STA %R0 @509 	#Limpa FPGA_RESET
tmp(69) := LDA & R0 & '0' & x"0A";	-- LDA %R0 @10
tmp(70) := STA & R0 & '0' & x"00";	-- STA %R0 @0 	#Salva mem[0] com o valor do acumulador
tmp(71) := STA & R0 & '0' & x"01";	-- STA %R0 @1 	#Salva mem[1] com o valor do acumulador
tmp(72) := STA & R0 & '0' & x"02";	-- STA %R0 @2 	#Salva mem[2] com o valor do acumulador
tmp(73) := STA & R0 & '0' & x"03";	-- STA %R0 @3 	#Salva mem[3] com o valor do acumulador
tmp(74) := STA & R0 & '0' & x"04";	-- STA %R0 @4 	#Salva mem[4] com o valor do acumulador
tmp(75) := STA & R0 & '0' & x"05";	-- STA %R0 @5 	#Salva mem[5] com o valor do acumulador
tmp(76) := STA & R0 & '0' & x"06";	-- STA %R0 @6 	#Salva mem[6] com o valor do acumulador
tmp(77) := STA & R0 & '1' & x"01";	-- STA %R0 @257 	#Apaga o LED[8] de overflow
tmp(78) := STA & R0 & '1' & x"02";	-- STA %R0 @258 	#Apaga o LED[9] de limite de contagem
tmp(79) := RET & R0 & '0' & x"00";	-- RET %R0
